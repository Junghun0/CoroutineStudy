## 코루틴 인 액션


### 안드로이드의 UI 스레드

안드로이드는 UI 를 업데이트하고 사용자와의 상호작용을 리스닝하며, 메뉴를 클릭하는 것과 같은 사용자에 의해 생성된 이벤트 처리를 전담하는 스레드가 있다.
할 수 있는 최선의 방법으로 UI 스레드와 백그라운드 스레드를 확실하게 분리하기 위해서, UI 스레드의 기본적인 사항들을 검토해본다.


### CallFromWrongThreadException

안드로이드는 뷰 계층을 생성하지 않은 스레드가 관련 뷰를 업데이트하려고 할 때마다 `CallFromWrongThreadException` 을 발생시킨다.
실제로 이 예외는 UI 스레드가 아닌 다른 스레드가 뷰를 업데이트할 때마다 발생한다. `UI 스레드` 만이 뷰 계층을 생성할 수 있는 스레드이며 뷰를 항상 업데이트할 수 있다.

UI를 업데이트하는 코드가 UI 스레드에서 실행되도록 보장하는 것이 중요하다.

### NetworkOnMainThreadException

자바에서의 네트워크 동작은 기본적으로 블로킹된다. UI 스레드가 블로킹된다는 것은 애니메이션이나 기타 상호작용을 포함한 모든 UI가 멈추는 것을 의미하므로, UI 스레드에서 네트워크 작업을 수행할 때마다 안드로이드는 중단된다.

### 백그라운드에서 요청하고, UI 스레드에서 업데이트할 것

두 가지를 합쳐서 서비스 호출을 구현하려면 백그라운드 스레드가 웹 서비스를 호출하고, 응답이 처리된 후에 UI 스레드에서 UI를 업데이트하도록 해야 한다.

## 스레드 생성

코틀린은 스레드 생성 과정을 단순화해서 쉽고 간단하게 스레드를 생성할 수 있다.
지금은 단일 스레드만으로도 충분하지만, 이후 과정에서는 CPU 바운드와 I/O 바운드 작업을 모두 효율적으로 수행하기 위해 스레드 풀도 생성할 것이다.

### CoroutineDispatcher

코틀린에서는 스레드와 스레드 풀을 쉽게 만들 수 있지만 직접 액세스하거나 제어하지 않는다는 점을 알아야 한다.
여기서는 CoroutineDispatcher 를 만들어야 하는데, 이것은 기본적으로 가용성, 부하, 설정을 기반으로 스레드 간에 코루틴을 분산하는 오케스트레이터다.

여기에서는 스레드를 하나만 갖는 `CoroutineDispatcher`를 생성할 것이며, 거기에 추가하는 모든 코루틴은 그 특정 스레드에서 실행된다.

그렇게 하려면 단 하나의 스레드만 갖는 `CoroutineDispatcher`를 확장한 `ThreadPoolDispatcher`를 생성한다.



